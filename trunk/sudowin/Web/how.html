<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html 	PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
	<head>
		<title>Sudo for Windows</title>
		<link href="css/default.css" rel="stylesheet" type="text/css" />
		<script type="text/javascript" src="scr/default.js"></script>
	</head>
	<body onload="onPageLoad();">
		<div id="divBody">
			
			<script type="text/javascript">
				writeTopPart();
			</script>
			
			<div class="divSection">
				<span class="spanSectionHeader">
					Basics
				</span>
				<p class="pSectionText">
					Sudo for Windows is at its core composed of two components -- the server and the client.  
					The client asks the server to escalate the user's privileges, and the server either 
					complies or refuses.
				</p>
				<p class="pSectionText">
					This is obviously a great simplification of how Sudo for Windows works.  To better 
					understand Sudo for Windows we will walk through a step-by-step invocation of sudowin.
				</p>
			</div>
			
			<div class="divSection">
				<span class="spanSectionHeader">
					Step-by-step
				</span>
				<ol>
					<li>
						Mandy invokes a sudowin client.
					</li>

					<li>
						The client tries to open a secure IPC channel to the server.  If Mandy is not a 
						a member of the configured sudoers group then the client canno open a 
						secure IPC channel to the server and Mandy is not allowed to continue
						<br /><br />
						If the user a member of the configured sudoers group then the process continues.
					</li>
					<li>
						If the secure IPC channel has been established then the server checks to see if Mandy 
						has cached credentials.  If Mandy has cached credentials then the process skips to Step 6.
						<br /><br />
						If Mandy does not have cached credentials then the appropriate response code is returned 
						to the client.
					</li>
					<li>
						The client prompts Mandy to enter her passphrase.  The client sends the Mandy's username, 
						passphrase, and the invoked command to the server.  The passphrase is sent in plain text, but since 
						it is sent over a secure IPC channel, this is ok.
					</li>

					<li>
						The server attempts to verify Mandy's passphrase using, in order, the configured authentication
						plugins.
						<br /><br />
						If server fails to authenticate Mandy then the server responds to the client with the appropriate 
						response code.  If a Mandy fails to authenticate several times in a row she will be locked out for 
						a given amount of time.
						<br /><br />
						The allowed retry count, retry window, and lockout length are all configuration options 
						for the server process.
						<br /><br/>
						If the server successfully authenticates Mandy then her credentials 
						are securely cached in memory for a configurable amount of time and the process continues
					</li>
					<li>
						The server attempts to authorize the invoked command using, in order, the configured 
						authorization plugins.
						<br /><br />
						If the server fails to authorize the command then Mandy the appropriate response code is 
						returned to the client and Mandy is not allowed to continue.
						<br /><br />
						If the command is successfully authorized then the process continue.
					</li>
					<li>
						<span style="color:black; font-weight:bold;">Windows 2000 and Windows XP</span>
						<br /><br />
						The server verifies that the server assembly and the callback assembly are signed 
						with the same strong name key.  If this verification fails then the appropriate 
						response code is returned to the client and Mandy is not allowed to continue.
						<br /><br />
						If the verification is successful then the process continues.
					</li>
					<li>
						The server then uses the .NET port of the Microsoft Windows Terminal Server API 
						(<a href="https://sourceforge.net/projects/wtsapi32net">wtsapi32.net</a>) to enumerate the users 
						logged onto the machine.  Once Mandy is found the server creates a reference to her
						logon token.
					</li>
					<li>
						The server then adds Mandy to the configured privilege escalation group.
					</li>
					<li>
						<span style="font-weight:bold;">Windows 2000 and Windows XP</span>
						<br /><br />
						The server then uses the win32 API function 
						<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/createprocessasuser.asp">CreateProcessAsUser</a> 
						to invoke the callback application in the security context of Mandy.  The server 
						sends the callback application the Mandy's passphrase and the invoked command and 
						waits for the callback application process to complete before continuing.
						<br /><br />
						<span style="font-weight:bold;">Windows Server 2003 and Windows Vista Beta 2</span>
						<br /><br />
						The server then uses the win32 API function 
						<a href="http://msdn.microsoft.com/library/en-us/dllproc/base/createprocesswithtokenw.asp">CreateProcessWithTokenW</a>
						to start the invoked command.
						<!--
						the callback application is necessary because the server must be able to run applications in the 
						desktop context (winstation) of the user who invoked the client.  otherwise i would have simply used the 
						win32 function <a href="http://msdn.microsoft.com/library/en-us/dllproc/base/createprocesswithlogonw.asp">CreateProcessWithLogonW</a>, 
						but this function does not take the user's logon token, which is what causes the process to be run in the 
						desktop context of the user.  there is a win32 function in windows vista that is the effective sweet spot,  
						<a href="http://msdn.microsoft.com/library/en-us/dllproc/base/createprocesswithtokenw.asp">CreateProcessWithTokenW</a>, 
						that takes logon token of the user and has the option of loading the user's profile.  loading the profile is important 
						because it causes the user's new group membership in the privileged group to be respected by the system.  
						since i want to retain windows xp compatibility (for now), i will continue to use the callback application.
						<br /><br />
						when windows vista is the windows desktop standard i will modify sudo for windows to use the win32 function 
						CreateProcessWithTokenW and eliminate the callback application altogether-->
					</li>
					<li>
						the callback application starts a new process with the command the user invoked sudo on with the 
						user's username and passphrase.  the callback application specifies that the user's profile should be 
						loaded causing the user's new group membership in the privileged group to be respected.
						<br /><br />
						currently the console client application that sudo for windows ships with also doubles as the callback 
						application.  although there is nothing at all unsafe or wrong with this, for the sake of satiating my 
						obsessive-compulsive tendencies to want things as clean as possible, these two applications will be 
						separate in future versions of sudo for windows
					</li>

					<li>
						the server detects that the callback application has completed and promptly removes the user from 
						the privileged group.
						<br /><br />
						this is why it is so important that the server and the callback application be signed with the same 
						strong name key or x509 certificate.  if this was not the case then some local administrator could 
						replace the callback application and stop the server from removing them from the privileged group.  
						this is one of the reasons that i am anxious for the day that vista is the de facto standard because 
						it will allow for the elimination of the callback application altogether
					</li>
					<li>
						that is sudo for windows in 3 easy steps!
					</li>
				</ol>
			</div>
		</div>
	</body>
</html>